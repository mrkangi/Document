# 精细化权限系统设计方案（功能+数据）

## 一、 概要

本文介绍的是一种应用于后台管理系统的通用权限设计方案，包含**功能**及**数据**的权限控制，主体采用类似于**RBAC**的权限设计思想，并引入了一种可行的数据权限控制方案（基于MySql的实践，已在内部人事系统实施）。

## 二、 基本思想

### 2.1 功能权限

`功能权限`定义为对页面上的可操作对象的权限控制。可操作对象这里主要指的是页面上的菜单及按钮，通过将菜单、按钮进行抽象，可以得到一个关于页面菜单、按钮关系的树形结构，在实际操作时，对该树形结构的任意分支进行限制，便可得到不同的`功能权限`。

### 2.2 数据权限

**数据权限**分为两个部分，对于一个列表来说，由行和列两部分组成，在某些场景下，同一个列表，不同的权限存在显示不同行列的情况，针对这种数据权限控制，需要将数据权限分为**数据行权限**和**数据列权限**。行权限主要用于控制一个列表显示哪些满足条件的行，例如某公司A部门的主管仅能在公司员工列表中看到A部门的员工。列权限则用于控制一个列表显示哪些数据项，例如某公司员工的薪资信息并不想在系统中暴露给所有系统的访问者，那么在员工信息列表中，薪资信息就需要被隐藏起来（用'*'或者其他方式）。这里将这种由行列数据权限称为**数据窗口**。数据窗口可以通过多个组合的方式，用于控制不规则的数据权限。

> Q: 什么是不规则的数据权限？
>
> A: 当同一个权限含有多个数据窗口时，如图1.1所示（可以将数据窗口看成矩形框），数据窗口存在三种位置关系，即内含、相交和相离。显然相交和相离就是所说的不规则的数据权限（无法用一个矩形表示）。
>
> Q: 为什么要用'*'号隐藏，而不是直接不显示？
>
> A: 这是由不规则数据权限引起的问题，通常一个表格的显示是一个矩形，但是当多个数据窗口组合时，一个矩形如果将两个相交的矩形包含进来（蓝框和绿框），会产生不在小矩形所包含范围内的部分，这部分数据显然是不可见的，所以为了保证显示的是一个矩形，就将这部分数据采用掩码（'*'号）的方式隐藏起来。

![相交的数据窗口](.\相交的数据窗口.png "相交的数据窗口")

## 三、 一种实现方式

### 3.1 组成部分

该权限体系主要由三部分组成，包括**用户**、**角色**和**权限**，其中**权限**又包括功能权限和数据权限。功能权限用来控制菜单、按钮等页面元素以及接口的可访问性，数据权限则用于控制可操作数据的范围。

### 3.2 实现

本文主要介绍**权限**部分的实现思路，对于**用户**，**角色**，**权限**之间的设计实现，已经有很多相关的（RBAC）文章了。下面仅作简单介绍。

#### 3.2.1 用户-角色-权限

![表设计](.\表设计.png "表设计")

如图2所示，角色-用户的关系是很明确的，这里有几个特殊的地方。首先为了方便，我将数据权限`data_rule`作为角色的属性进行处理，并且以json的格式进行存储，一个`data_rule`表示一个数据窗口，这也就意味着，在上面的设计中一个角色仅能表示标准数据窗口（如果有需要的话，也可以将`data_rule`独立出来），即标准矩形视图。`menus`表用于存放菜单和按钮的配置，因为一般的菜单按钮都是层级（树形）结构的，所以这里采用`pid`表示其父元素id，`path`表示元素的id路径，`url`表示菜单点击时跳转的具体链接，`type`则用于区分按钮和菜单。这里有必要解释一下`actions`，这里的`actions`是一个json结构，实际上是数组，用于存放该菜单或按钮所允许调用的接口。因此在开发时，需要建立这部分关系。

> 在一些设计方案里，接口和菜单是分离配置的，这种配置容易导致授权时发生冲突。上述的方案解决了这个问题，但是也引入了更多的工作量（搭建菜单和接口的关系，这里有考虑过自动化，但是没找到具体可实现的方案，如有想法可以一起交流）

基本的关系构建好之后，后面详细解释功能权限以及数据权限的实现思路。

#### 3.2.2 功能权限

功能权限这部分实际限制的是对接口的调用，从3.2.1节所描述的内容可以知道，根据配置是可以获取到某一用户所允许使用的接口的，这里仅需要检查实际访问的接口是否是允许访问的即可。

在实际开发中，我将接口分为了三种权限级别，分别是`open`，`login`和`strict`，其中`open`表示无需权限控制，即不用登陆也可访问，`login`表示该接口登录后即可使用，无需明确配置，`strict`则表示严格授权模式，即该接口必须明确的存在于用户的接口允许列表中。以上级别在具体的实现中可以根据自己的业务进行调整。

对于接口控制，则是采用路由拦截+特性的方式，使用特性对Action的级别进行标注，路由到达后根据所访问Action的级别进行判断，若为`strict`则进行接口是否已授权的验证，若为`login`则验证是否已登陆，`open`则直接放行。对于一些没有进行标注的Action，可以采用默认级别的方案，如默认`login`。

> 实际情况可能比上述的情况要复杂一点，在实际开发中，我对所有需要配置的接口都使用特性进行了命名，以便于在配置时显示的是可以被理解的文字描述，而不是url路径。因为在配置时，显示的接口数据是从代码中获取的。

#### 3.2.3 数据权限

数据权限的主要设计思想为**数据窗口**，根据该思想，有两种形式的数据窗口设计方案，一种是**数据库级别**的数据窗口，另一种是**用户视图级别**的数据窗口，下面分别介绍。

##### 3.2.3.1 数据库级别

数据库级别指的是，数据窗口是基于数据库表的。下面使用一个简单的示例做介绍。

user表：

| user_id | user_name | user_birthday | user_gender |
| ------- | --------- | ------------- | ----------- |
| 1       | 小明        | 1993-01-12    | 男           |
| 2       | 李华        | 1994-11-05    | 女           |
| 3       | 张三        | 1982-05-23    | 男           |

score表：

| score_id | score_uid | score_value | score_subject |
| -------- | --------- | ----------- | ------------- |
| 1        | 1         | 78          | 英语            |
| 2        | 1         | 85          | 数学            |
| 3        | 2         | 91          | 英语            |
| 4        | 3         | 62          | 语文            |

现有如上两张表及部分数据，`user`表为用户表，包含姓名，生日及性别，`score`表为成绩表，用户id，成绩值，以及科目。上面提到，数据库级别的数据窗口是基于数据库表的，那么在设置对应的权限时，是针对每张表独立设置的，下面用json结构进行数据窗口设置的描述，即3.2.1节所介绍的`data_rule`字段。

```json
{
  "row":{
    "user":{
      "user_gender":{
        "$eq":"男"
      }
    },
    "score":{
      "score_value":{
        "$gte":85
      }
    }
  },
  "column":{
    "user":[
      "user_name",
      "user_gender"
    ],
    "score":[
      "score_value",
      "score_subject"
    ]
  }
}
```

> 这里的`row`表示**数据行权限**，`column`表示**数据列权限**，其中的字段名与数据库中的名称对应，在设置的时候是直接从数据库中获取的模式数据。

以上json结构表示，规则生效时，user表仅能获取**性别**为`男`的用户，且仅显示**姓名**及**性别**两列数据，score表仅能获取**成绩值**大于等于`85`分的数据，且仅显示**成绩值**以及**科目**。下面针对一些实际查询情况做说明。

```mysql
1. select * from user;
```

当上面的查询语句经过数据窗口后，会被处理成如下形式：

```mysql
2. select user_name,user_gender from `user` where user_gender = '男'
```

可以看出，语句1会选择出所有的user表中的数据，但是在数据窗口的控制下（控制了`select_expr`及`where_condition`），得到的语句2仅能获取到男性用户的姓名及性别数据，起到了数据权限限制的作用。

对于一般的join查询，数据窗口也能起到很好的效果，如下。

```mysql
3. select * from `score` left join `user` on score_uid = user_id;
```

被数据窗口处理后。

```mysql
4. select score_value,score_subject,user_name,user_gender from `score` left join `user` on score_uid = user_id where user_gender = '男' and score_value >= 85;
```

处理后的语句仅能获取到男性用户大于等于85分以上的成绩，且仅显示成绩值，科目，姓名及性别等字段。

>两种可能的数据窗口处理实现思路：
>
>1. 对sql进行解析
>
>   对sql进行解析后，就可以对每个组成部分处理，并加入自己的构造好的限制语句。这种方式对于不了解编译原理的人来说有一定的难度，主要在于sql解析这部分。（可以考虑开源方案）
>
>2. 对sql进行建模
>
>   对sql进行建模后，构造sql语句时实际是在操作模型，模型的各属性即表示sql的不同部分，免去了sql语法分析，可以直接在模型基础上添加限制。这种方式相对简单，但是对于已经使用了很大数量sql的系统来说，改造成本不小。

数据库级别的数据窗口是存在一定**缺陷**的，在上面是示例中，仅获取`score`表中的数据和获取与`user`join后的数据，条目是不同的，显然没有join的数据条目更多，而且其中有部分数据可能是不想被展示的（如女性用户李华的成绩），这种情况是由于我们在构造**数据窗口**时，并没有构建表之间的关系（每个表之间的设置都是互相独立的），这就导致我们在实际查询数据时，可能需要join所有相关（间接或直接）的表来构造这种关系（具体是否join取决于要查询什么样的数据），这样显然有一定的性能问题。

##### 3.2.3.2 用户视图级别

与数据库级别不同的是，用户视图级别的数据窗口直接作用于面向用户的数据上，假设用户界面有如下数据展示。

成绩列表：

| 姓名   | 成绩   | 科目   |
| ---- | ---- | ---- |
| 小明   | 78   | 英语   |
| 小明   | 85   | 数学   |
| 李华   | 91   | 英语   |
| 张三   | 62   | 语文   |

此时我们的数据权限需要先配置好该列表允许配置的权限，假设成绩和科目是可配置的，那么可以根据这样的配置进行数据窗口的构建，如下。

```json
{
  "row":{
    "成绩列表":{
      "科目":{
        "$eq":"英语"
      }
    }
  },
  "column":{
    "成绩列表":[
      "成绩",
      "科目"
    ]
  }
}
```

成绩列表在被数据窗口过滤后，得到如下数据：

成绩列表（应用数据权限后）：

| 成绩   | 科目   |
| ---- | ---- |
| 78   | 英语   |
| 91   | 英语   |

可以看到，这种形式的数据窗口，是作用于查询后的数据的。由于数据窗口对列表的影响相互独立（列表之间也是相互独立的），所以这种方式更加灵活，但是在实现方面会比数据库级别的增加一定的代码量，这部分代码主要用于维护列表与其对应的可配置信息之间的关系。不过在实现时，还是可以通过构造sql语句的方式对数据进行过滤。

当然这种数据窗口也是有明显**缺陷**的，主要体现在配置时，容易配置出**不一致**的权限。例如仅能看科目为英语的用户，在某一个列表中由于疏忽遗漏了对科目的限制导致可以看到全部数据。而这在数据库级别的权限中很难发生（配置一处全局生效）。

##### 3.2.3.3 小结 

上面对两种可能的数据窗口的实现思路进行了基本介绍，虽然都仅针对**查询**做的说明，但是很容易将其使用在**更新**和**删除**上面。在一个实际项目中，我选择了数据库级别的数据窗口来对数据进行权限控制，主要由于它从底层进行控制，可以达到全局权限一致的效果，相应的代码也会简洁很多。不过具体选择还是取决于业务需要，对于一些较大型，对数据权限要求不普遍的系统来说，用户视图级别可能是更好的选择，因为它更灵活，可控性好，能够降低数据权限对系统带来的风险。

#### 3.2.4 非规则的数据权限

当同一张（列）表的多个数据窗口同时生效时（一个用户拥有多个角色），就可能产生非规则的数据权限。如第2.2节的图1所示，这里每个窗口允许显示的字段不同，数据显示条件也不同，而且还有重叠部分，因此需要知道查询出的每条数据满足哪些窗口的条件，以显示对应窗口允许显示的字段。这里在实现时，我采用了MySql提供的`IF(Condition,A,B)`函数，用于判断该条数据所满足的数据窗口，下面做简单介绍。

> Q：为什么不直接组合多个数据窗口的**行权限**和**列权限**？
>
> A：简单的组合行权限和列权限会导致数据窗口被放大，变成一个包含了多个数据窗口的最小矩形，这显然会使一些不包含在两个数据窗口中的数据被显示出来。

假设我们现在有A,B,C三个个数据窗口，A,B,C分别对应的条件为`cond1`,`cond2`,`cond3`，如果我们需要知道这三个条件中哪几个满足这条数据，需要做3次判断，组合结果有$2^{n}$个，简单表示如下
![条件分支树](.\条件分支树.png "条件分支树")
对于每个节点，左分支表示条件为假时的路径，右分支表示条件为真时的路径，我们用0表示假，用1表示真，则有如下结构
![条件分支树(含值)](.\条件分支树(含值).png "条件分支树(含值)")
由上面可以看出，得到的结果是对应$[0,2^{n-1}]$的二进制，所以我们仅需要构造如下表达式即可

```mysql
IF(cond1,IF(cond2,IF(cond3,7,6),IF(cond3,5,4)),IF(cond2,IF(cond3,3,2),IF(cond3,1,0)))
```

通过这个表达式得到的值，可以推算出当前数据满足的条件，以及是哪几个角色所能访问的，进而得到哪些字段是允许访问的。下面展示一个例子。

假设有三个角色，配置分别如下（这里仅针对3.2.3.1节的user表描述）：

1. 角色A，数据行权限为`user_gender = '男'`，数据列权限为`user_id,user_name`；
2. 角色B，数据行权限为`user_birthday < '1990-01-01'`，数据列权限为`user_id,user_birthday`；
3. 角色C，数据行权限为`user_name = '张三'`，数据列权限为`user_id` 。

```mysql
SELECT IF(user_gender = '男',
          IF(user_birthday < '1990-01-01',
             IF(user_name = '张三',7,6),
             IF(user_name = '张三',5,4)),
          IF(user_birthday < '1990-01-01',
             IF(user_name = '张三',3,2),
             IF(user_name = '张三',1,0))) __flag__,
user_id,
user_name,
user_birthday
from `user` where 
(user_gender = '男') or
(user_birthday < '1990-01-01') or 
(user_name = '张三');
```

执行之后可以得到下面的数据：

| \_\_flag\_\_ | user_id | user_name | user_birthday |
| ------------ | ------- | --------- | ------------- |
| 4            | 1       | 小明        | 1993-01-12    |
| 7            | 3       | 张三        | 1982-05-23    |

当我们的权限模块获取到如上数据的时候，通过判断`__flag__`字段，得到当前数据行所满足的角色，如第一条数据`__flag——`为4，则表示满足角色A，不满足角色B，C，角色A的数据列权限为`user_id,user_name`，第一条数据的`user_birthday`将被掩码（如"***"）替代，第二条数据`__flag__`为7，满足角色A，B和C，则字段`user_id,user_name,user_birthday`会被显示。

>这种方式实际上有一个致命的缺陷，sql语句的长度随着同一用户角色数量的增多程指数型增长，所以应用这种方案的时候要非常小心的限制同一用户所拥有的角色数量，以免发生sql爆炸。
>
>为了避免sql爆炸，可以选择另外一种方式，那就是在权限模块内重新对数据所满足的条件进行判断，这里就需要权限模块与数据库拥有一致的条件处理逻辑。

## 四、扩展功能

### 4.1 组

仅有用户和角色的权限设置方式，在进行角色分配时，相同角色的用户会进行相同角色分配操作若干次，很不方便，此时可以引入**组**的概念，**组**是一个集合，用于间接关联用户和角色，例如有一个管理员组，管理员组拥有若干角色，此时再次进行权限分配时，仅需要将用户加入至组即可，在管理和操作方面会方便很多。

### 4.2 组织架构

有一些系统的数据存在明显的区域划分，例如人事系统，一般员工数据都会由相应的部门，组进行管理，在设置权限时，引入组织架构使这种划分更容易理解。

组织架构级别的权限类似于给数据加了第一层过滤，例如一个用户在A部门并设置了部门级别的权限，那么这个用户仅能看到A部门的数据，无论他的角色是什么。这里有个好处是，当他转入B部门时，这种权限关系是会变化的，他的可见数据也变成了B部门。

### 4.3 小结

除了核心部分以外，其他的扩展功能都是可以根据需求进行一定的增改的，上面介绍的两种也是实际开发时用到一些部分。

## 五、总结

本文所讲的**数据权限**以及**功能权限**是我在实际开发中所进行的一种尝试，在使用了一段时间之后，发现基本满足我们对数据权限的控制要求，文章中的内容是对我设计权限控制的一些关键点的记录，希望分享出来，集思广益，逐步完善这种设计，或者寻找更好的解决方案。

文章的内容会随着我对权限理解的加深逐步完善。

参考文献：

1. jeecg快速开发平台
2. https://www.cnblogs.com/shijiaqi1066/p/3793894.html
3. https://dev.mysql.com/doc/refman/5.7/en/select.html